Most of the information in this post are learned from experimentation. If you have better ways to do this, please tell me.

# The problem

I have a static lib (.lib, .a) that has some symbols inside it.

I have a dylib (.dll, .so, .dylib) where I want to reexport some of the symbols (usually functions) from the staticlib.

This has some usecases:
- maybe I'm trying to link zlib (or any other lib) statically into my core dylib, and have all the dylibs that depend on it also have it accesible, without duplicating the generated code
- maybe I want to logically split my lib into several smaller staticlibs, that still get exported through the same final dylib
- maybe I have a staticlib generated by Rust that's morally a dylib, but because I want to integrate it in a C++ project, it's easier to just have CMake generate the final dylib

# How to test

On this repo, you'll find a test project that you can experiment with the diverse solutions.
The following directory/targets can be seen:
- `common`: contains a header with code that'll be used by all other targets, including functions declarations
- `the_staticlib`: a staticlib that contains functions like `staticlib_symbol_1`, `staticlib_symbol_2`
- `the_dylib`: the dylib that links the the_staticlib and wants to export both its own symbol `dylib_symbol_1`, and `staticlib_symbol_1`
- `the_bin`: a binary that links `the_dylib`, and where we expect the errors to happen

# Solution 1 - Windows specific

On Windows, to export a symbol from a dll, we need to mark it as [dllexport](https://learn.microsoft.com/en-us/cpp/cpp/dllexport-dllimport):
```cpp
__declspec(dllexport) void dylib_symbol_1();
__declspec(dllexport) void staticlib_symbol_1();
```

