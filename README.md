Most of the information in this post are learned from experimentation. If you have better ways to do this, please tell me.

# The problem

I have a static lib (.lib, .a) that has some symbols inside it.

I have a dylib (.dll, .so, .dylib) where I want to reexport some of the symbols (usually functions) from the staticlib.

This has some usecases:
- maybe I'm trying to link zlib (or any other lib) statically into my core dylib, and have all the dylibs that depend on it also have it accesible, without duplicating the generated code
- maybe I want to logically split my lib into several smaller staticlibs, that still get exported through the same final dylib
- maybe I have a staticlib generated by Rust that's morally a dylib, but because I want to integrate it in a C++ project, it's easier to just have CMake generate the final dylib

# How to test

On this repo, you'll find a test project that you can experiment with the diverse solutions.
The following directory/targets can be seen:
- `common`: contains a header with code that'll be used by all other targets, including functions declarations
- `the_staticlib`: a staticlib that contains functions like `staticlib_symbol_1`, `staticlib_symbol_2`
- `the_dylib`: the dylib that links the the_staticlib and wants to export both its own symbol `dylib_symbol_1`, and `staticlib_symbol_1`
- `the_bin`: a binary that links `the_dylib`, and where we expect the errors to happen

# Investigating on Windows

On Windows, to export a symbol from a dll, we need to mark it as [dllexport](https://learn.microsoft.com/en-us/cpp/cpp/dllexport-dllimport):
```cpp
__declspec(dllexport) void dylib_symbol_1();
__declspec(dllexport) void staticlib_symbol_1();
```

We can check the exports of a dll as following:
```
C:\repos\reexport_from_dylib\bin\Release>dumpbin /exports the_dylib.dll
Microsoft (R) COFF/PE Dumper Version 14.43.34808.0
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file the_dylib.dll

File Type: DLL

  Section contains the following exports for the_dylib.dll

    00000000 characteristics
    FFFFFFFF time date stamp
        0.00 version
           1 ordinal base
           2 number of functions
           2 number of names

    ordinal hint RVA      name

          1    0 00001000 dylib_symbol_1
```

We can see the symbol from `the_dylib`, but not the once from `the_staticlib`. I really believed this would work from the start on Windows with `dllexport`, but I was wrong.

Why does this happen?

It seems like the linker has an algorithm as following:
- search all objs (.obj, .o) for symbols marked as `dllexport`, and include them
- include all the dependencies of the above symbols

This is the reason why the symbols from `the_staticlib` don't appear in the first place. The linker discards unused 